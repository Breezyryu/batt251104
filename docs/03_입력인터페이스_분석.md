# 입력 인터페이스 상세 분석

## 개요

BatteryDataTool.py에서 추출할 **입력 인터페이스 구성요소**에 대한 상세 분석 문서입니다.
총 150+ 입력 위젯을 분석하여 통합 설정 시스템으로 재설계합니다.

---

## 핵심 입력 인터페이스 (Cycle/Profile 분석용)

### 1. 경로 입력 시스템

#### 1.1 경로 선택 방식 (3가지)

**방식 1: 다중 폴더 직접 선택**
```python
# 사용자가 파일 탐색기에서 여러 폴더 선택
all_data_folder = multi_askopendirnames()

# 함수: multi_askopendirnames() (line 189)
# 반환: List[str] - 선택된 폴더 경로 리스트
```

**방식 2: TSV 파일 기반 경로 로드**
```python
# Widget: chk_cyclepath (QCheckBox)
if self.chk_cyclepath.isChecked():  # 기본값: True
    datafilepath = filedialog.askopenfilename(
        title="TSV 파일 선택",
        filetypes=[("TSV files", "*.tsv"), ("All files", "*.*")]
    )
    data_pathlist = pd.read_csv(datafilepath, sep='\t', encoding='utf-8')
    # TSV 컬럼: cyclepath | cyclename
```

**방식 3: 수동 경로 입력**
```python
# Widget: stepnum_2 (QPlainTextEdit)
# 사용자가 직접 경로 입력 (줄바꿈으로 구분)
path_input = self.stepnum_2.toPlainText()
all_data_folder = path_input.split('\n')
```

#### 1.2 경로 설정 통합 함수

**함수**: `pne_path_setting()` (line 8074)
```python
def pne_path_setting(self):
    """경로 설정 통합 함수"""

    if self.chk_cyclepath.isChecked():
        # TSV 파일 기반
        datafilepath = filedialog.askopenfilename(...)
        data_pathlist = pd.read_csv(datafilepath, sep='\t')
        all_data_folder = data_pathlist['cyclepath'].tolist()
        all_data_name = data_pathlist['cyclename'].tolist()

    elif self.stepnum_2.toPlainText() != "":
        # 수동 입력
        all_data_folder = self.stepnum_2.toPlainText().split('\n')
        all_data_name = []
        datafilepath = ""

    else:
        # 다중 폴더 선택
        all_data_folder = multi_askopendirnames()
        all_data_name = []
        datafilepath = ""

    return [all_data_folder, all_data_name, datafilepath]
```

**반환값**:
- `all_data_folder`: List[str] - 폴더 경로 리스트
- `all_data_name`: List[str] - 사이클명 리스트 (옵션)
- `datafilepath`: str - TSV 파일 경로 (옵션)

#### 1.3 사이클러 자동 감지

**함수**: `check_cycler(path)` (line 286)
```python
def check_cycler(cyclefolder):
    """사이클러 타입 자동 감지"""
    # "Pattern" 폴더 존재 여부로 판단
    pattern_path = os.path.join(cyclefolder, "Pattern")

    if os.path.exists(pattern_path):
        return True  # PNE
    else:
        return False  # Toyo
```

#### 1.4 TSV 파일 형식

**연결 Cycle용 TSV**:
```tsv
cyclepath	cyclename
Rawdata\250207_250307_3_김동진_1689mAh_ATL Q7M Inner 2C 상온수명 1-100cyc	1-100cyc
Rawdata\250219_250319_3_김동진_1689mAh_ATL Q7M Inner 2C 상온수명 101-200cyc	101-200cyc
Rawdata\250304_250404_3_김동진_1689mAh_ATL Q7M Inner 2C 상온수명 201-300cyc	201-300cyc
```

**필수 컬럼**:
- `cyclepath`: 데이터 폴더 경로
- `cyclename`: 사이클 이름 (범례 표시용)

---

### 2. 용량 설정 시스템

#### 2.1 용량 입력 방식 (2가지)

**방식 1: C-rate 기반 자동 감지** (기본값)
```python
# Widget: inicaprate (QRadioButton) - 기본 선택
# Widget: ratetext (QLineEdit) - 기본값: "0.2"

if self.inicaprate.isChecked():
    firstCrate = float(self.ratetext.text())  # 0.2
    mincapacity = 0  # 자동 감지 플래그

    # 실제 용량은 데이터 처리 함수에서 계산
    # - 옵션 1: 파일명에서 추출 (name_capacity 함수)
    # - 옵션 2: 첫 사이클의 방전 용량 사용
```

**방식 2: 직접 입력**
```python
# Widget: inicaptype (QRadioButton)
# Widget: capacitytext (QLineEdit) - 기본값: "58"

if self.inicaptype.isChecked():
    mincapacity = float(self.capacitytext.text())  # 58 mAh
```

#### 2.2 파일명에서 용량 추출

**함수**: `name_capacity(filepath)` (line 233)
```python
def name_capacity(filepath):
    """파일명에서 용량 추출"""
    # 정규식 패턴: (\d+([-.]\d+)?)mAh
    # 예) "Battery_58mAh.csv" → 58.0
    # 예) "Test_4-5mAh.csv" → 4.5
    # 예) "Cell_3.2mAh.csv" → 3.2

    match = re.search(r'(\d+([-.]\d+)?)mAh', filepath)
    if match:
        capacity_str = match.group(1).replace('-', '.')
        return float(capacity_str)
    else:
        return None
```

#### 2.3 용량 설정 적용 (cyc_ini_set)

**함수**: `cyc_ini_set()` (line 8030)
```python
def cyc_ini_set(self):
    """Cycle 분석 파라미터 초기화"""

    firstCrate = float(self.ratetext.text())  # 0.2

    if self.inicaprate.isChecked():
        mincapacity = 0  # 자동 감지
    elif self.inicaptype.isChecked():
        mincapacity = float(self.capacitytext.text())  # 58

    xscale = float(self.tcyclerng.text())  # 0 (자동)
    ylimithigh = float(self.tcyclerngyhl.text())  # 1.10
    ylimitlow = float(self.tcyclerngyll.text())  # 0.65
    irscale = float(self.dcirscale.text())  # 0 (자동)

    return firstCrate, mincapacity, xscale, ylimithigh, ylimitlow, irscale
```

---

### 3. 사이클/Step 번호 입력

#### 3.1 사이클 번호 입력 위젯

**Widget**: `stepnum` (QPlainTextEdit)
- **위치**: Lines 2790-2801
- **기본값**: "2"
- **라벨**: "Cycle\n(원하는 스텝들을 띄어쓰기나 -로 표기)\n예) 3 4 5 8-9"

#### 3.2 입력 형식

**형식 1: 공백 구분 개별 숫자**
```
입력: "3 4 5 8 9"
파싱 결과: [3, 4, 5, 8, 9]
```

**형식 2: 범위 표기**
```
입력: "8-9"
파싱 결과: [8, 9]
```

**형식 3: 혼합**
```
입력: "3 4 5 8-9"
파싱 결과: [3, 4, 5, 8, 9]
```

**형식 4: 연속 범위 (DCIR 전용)**
```
입력: "3-5"
파싱 결과: range(3, 6) → 사이클 3, 4, 5를 연속 데이터로 처리
```

#### 3.3 파싱 함수

**함수 1**: `convert_steplist(stepnum_text)` - 개별 사이클 리스트 변환
```python
def convert_steplist(stepnum):
    """개별 사이클 번호 리스트 변환

    Args:
        stepnum: 사이클 입력 문자열 (예: "3 4 5 8-9")

    Returns:
        List[int]: 확장된 사이클 번호 리스트
        예: "3 4 5 8-9" → [3, 4, 5, 8, 9]
    """
    steplist = []
    for step in stepnum.split():
        if '-' in step:
            start, end = map(int, step.split('-'))
            steplist.extend(range(start, end + 1))
        else:
            steplist.append(int(step))

    return steplist
```

**함수 2**: `parse_cycle_range(cycle_input)` - 연속 사이클 범위 파싱
```python
def parse_cycle_range(cycle_input: str) -> tuple:
    """연속 사이클 범위 파싱 (시작/종료 값 반환)

    Args:
        cycle_input: 범위 형식 문자열 (예: "3-5")

    Returns:
        tuple: (Step_CycNo, Step_CycEnd) - (시작 사이클, 종료 사이클)
        예: "3-5" → (3, 5)

    Raises:
        ValueError: 범위 형식이 아닌 경우

    사용처:
        - DCIR 연속 범위 처리
        - Profile Continue 기능
        - 연속 데이터 병합 처리
    """
    if "-" not in cycle_input:
        raise ValueError("Range format required (e.g., '3-5')")

    cycle_range = cycle_input.strip()
    Step_CycNo, Step_CycEnd = map(int, cycle_range.split("-"))

    return Step_CycNo, Step_CycEnd
```

**함수 3**: `get_all_cycles()` - 전체 사이클 자동 로딩
```python
def get_all_cycles(data_path: str) -> tuple:
    """데이터 경로의 전체 사이클 범위 자동 감지

    Args:
        data_path: 배터리 데이터 폴더 경로

    Returns:
        tuple: (Step_CycNo, Step_CycEnd) - (첫 사이클, 마지막 사이클)
        예: 데이터에 사이클 1~100이 있으면 → (1, 100)

    사용처:
        - 전체 사이클 로딩 (사용자 입력 불필요)
        - 전체 데이터 분석 및 통계
        - 초기 데이터 로드 시 범위 확인
    """
    # 사이클러 타입 감지
    is_pne = check_cycler(data_path)

    if is_pne:
        # PNE: SaveData*.csv 파일 번호로 사이클 범위 추출
        # 예: SaveData1.csv ~ SaveData100.csv
        pass
    else:
        # Toyo: Raw data의 Condition 컬럼으로 사이클 범위 추출
        pass

    return Step_CycNo, Step_CycEnd
```

**함수 사용 구분**:
- **함수 1 (convert_steplist)**: 개별 사이클 분석용 (Individual, Step, Rate, Charge, Discharge)
  - 입력: "3 4 5 8-9"
  - 출력: [3, 4, 5, 8, 9] (각 사이클 개별 처리)

- **함수 2 (parse_cycle_range)**: 연속 범위 분석용 (DCIR, Continue Profile)
  - 입력: "3-5"
  - 출력: (3, 5) (사이클 3~5를 연속 데이터로 병합)

- **함수 3 (get_all_cycles)**: 전체 사이클 자동 로딩용
  - 입력: 데이터 경로
  - 출력: (1, 100) (사용자 입력 없이 전체 범위 자동 감지)

---

### 4. Cycle 관련 파라미터

#### 4.1 그래프 축 범위 설정

**X축 최대값**
```python
# Widget: tcyclerng (QLineEdit)
# 기본값: "0" (자동)
# 라벨: "X축 최대"
xscale = float(self.tcyclerng.text())
if xscale == 0:
    # 자동 스케일 (최대 사이클 번호로 설정)
```

**Y축 용량 비율 범위**
```python
# Widget: tcyclerngyhl (QLineEdit)
# 기본값: "1.10"
# 라벨: "Y축 최대"
ylimithigh = float(self.tcyclerngyhl.text())

# Widget: tcyclerngyll (QLineEdit)
# 기본값: "0.65"
# 라벨: "Y축 최소"
ylimitlow = float(self.tcyclerngyll.text())
```

#### 4.2 DCIR 옵션 (3가지 측정 방식)

**옵션 1: 표준 DCIR**
```python
# Widget: dcirchk (QRadioButton)
# 라벨: "PNE 설비 DCIR (SOC100 10s 방전 Pulse)"
if self.dcirchk.isChecked():
    # SOC 100%에서 10초 방전 펄스 사용
```

**옵션 2: Pulse DCIR**
```python
# Widget: pulsedcir (QRadioButton)
# 라벨: "PNE 10s DCIR (SOC5, 50 10s 방전 Pulse)"
if self.pulsedcir.isChecked():
    # SOC 5%, 50%에서 10초 방전 펄스 사용
```

**옵션 3: RSS DCIR** (기본값)
```python
# Widget: mkdcir (QRadioButton)
# 라벨: "PNE RSS DCIR (SOC 30/50/70 충/방전, 1s Pulse/RSS)"
# 기본값: Checked
if self.mkdcir.isChecked():
    # SOC 30/50/70%에서 충전/방전 펄스
    # 1초 펄스 및 RSS 계산
```

**DCIR 축 스케일**
```python
# Widget: dcirchk_2 (QCheckBox)
# 라벨: "DCIR 고정 해제"
# 기본값: Unchecked (고정)

# Widget: dcirscale (QLineEdit)
# 기본값: "0" (자동)
# 라벨: "DCIR scale 늘리기 (x ?배)"
irscale = float(self.dcirscale.text())
if irscale > 0:
    # DCIR 값에 irscale 곱하기
```

---

### 5. Profile 관련 파라미터

#### 5.1 Profile 타입 선택

**사이클 통합 (기본값)**
```python
# Widget: CycProfile (QRadioButton)
# 기본값: Checked
# 라벨: "사이클 통합"
if self.CycProfile.isChecked():
    # 외부 루프: 폴더
    # 내부 루프: 채널 → 사이클
    # 결과: 폴더별 탭
```

**셀별 통합**
```python
# Widget: CellProfile (QRadioButton)
# 라벨: "셀별 통합"
if self.CellProfile.isChecked():
    # 외부 루프: 사이클
    # 내부 루프: 폴더 → 채널
    # 결과: 사이클별 탭
```

#### 5.2 전압 축 설정

```python
# Widget: volrngyhl (QLineEdit)
# 기본값: "2.5"
# 라벨: "전압 Y축 하한"
vol_y_hlimit = float(self.volrngyhl.text())

# Widget: volrngyll (QLineEdit)
# 기본값: "4.7"
# 라벨: "전압 Y축 상한"
vol_y_llimit = float(self.volrngyll.text())

# Widget: volrnggap (QLineEdit)
# 기본값: "0.1"
# 라벨: "전압 Y축 간격"
vol_y_gap = float(self.volrnggap.text())
```

#### 5.3 dQ/dV 처리 파라미터

**Smoothing**
```python
# Widget: smooth (QLineEdit)
# 기본값: "0" (자동)
# 라벨: "Smooth (0 이면 자동)"
smoothdegree = int(self.smooth.text())

if smoothdegree == 0:
    # 자동 계산: 데이터 길이 / 30
    smoothdegree = len(df.Profile) / 30
    if smoothdegree % 2 == 0:
        smoothdegree += 1  # 홀수로 조정
```

**Cutoff (전류/전압 임계값)**
```python
# Widget: cutoff (QLineEdit)
# 기본값: "0"
# 라벨: "컷오프 (전류,전압)"
mincrate = float(self.cutoff.text())

# 사용: 임계값 이하 데이터 필터링
df = df[df["Crate"] > mincrate]
```

**dQ/dV 스케일**
```python
# Widget: dqdvscale (QLineEdit)
# 기본값: "1"
# 라벨: "dQdV 축늘리기"
dqscale = float(self.dqdvscale.text())
dvscale = dqscale  # dV/dQ도 동일 스케일

# 사용: dQ/dV 및 dV/dQ 축 범위 조정
```

**X/Y 축 교환**
```python
# Widget: chk_dqdv (QCheckBox)
# 기본값: Unchecked
# 라벨: "dQdV X/Y축 변환"
if self.chk_dqdv.isChecked():
    ax.plot(Vol_smt, dQdV)  # Voltage vs dQ/dV
else:
    ax.plot(dQdV, Vol_smt)  # dQ/dV vs Voltage (기본)
```

#### 5.4 Profile 초기화 함수

**함수**: `Profile_ini_set()` (line 8043)
```python
def Profile_ini_set(self):
    """Profile 분석 파라미터 초기화"""

    firstCrate = float(self.ratetext.text())  # 0.2

    if self.inicaprate.isChecked():
        mincapacity = 0
    elif self.inicaptype.isChecked():
        mincapacity = float(self.capacitytext.text())

    CycleNo = convert_steplist(self.stepnum.toPlainText())  # [2]
    smoothdegree = int(self.smooth.text())  # 0
    mincrate = float(self.cutoff.text())  # 0
    dqscale = float(self.dqdvscale.text())  # 1
    dvscale = dqscale

    vol_y_hlimit = float(self.volrngyhl.text())  # 2.5
    vol_y_llimit = float(self.volrngyll.text())  # 4.7
    vol_y_gap = float(self.volrnggap.text())  # 0.1

    return (firstCrate, mincapacity, CycleNo, smoothdegree,
            mincrate, dqscale, dvscale)
```

---

### 6. 내보내기 설정

#### 6.1 Excel 내보내기

```python
# Widget: saveok (QCheckBox)
# 기본값: Unchecked
# 라벨: (코드에 명시 안 됨, GUI에서 "데이터 저장"으로 추정)

if self.saveok.isChecked():
    save_file_name = filedialog.asksaveasfilename(
        defaultextension=".xlsx",
        filetypes=[("Excel files", "*.xlsx")]
    )

    if save_file_name:
        writer = pd.ExcelWriter(save_file_name, engine="xlsxwriter")
        df.to_excel(writer, sheet_name="Sheet1", index=False)
        writer.close()
```

#### 6.2 ECT CSV 내보내기 (Step/Rate만)

```python
# Widget: ect_saveok (QCheckBox)
# 기본값: Unchecked
# 라벨: "ECT로 데이터 저장"

if self.ect_saveok.isChecked():
    save_file_name = filedialog.asksaveasfilename(
        defaultextension=".csv",
        filetypes=[("CSV files", "*.csv")]
    )

    if save_file_name:
        # ECT 형식: Time(s), Voltage(V), Current(A), Temp(°C)
        ect_df = pd.DataFrame({
            'Time': df.stepchg["TimeMin"] * 60,  # 분 → 초
            'Voltage': df.stepchg["Vol"],
            'Current': df.stepchg["Crate"] * mincapacity / 1000,
            'Temp': df.stepchg["Temp"]
        })
        ect_df.to_csv(save_file_name, index=False)
```

#### 6.3 그래프 저장

```python
# Widget: figsaveok (QCheckBox)
# 기본값: Unchecked
# 라벨: (코드에 명시 안 됨, "그래프 저장"으로 추정)

if self.figsaveok.isChecked():
    fig_filename = filedialog.asksaveasfilename(
        defaultextension=".png",
        filetypes=[("PNG files", "*.png"), ("PDF files", "*.pdf")]
    )
    if fig_filename:
        fig.savefig(fig_filename, dpi=300, bbox_inches='tight')
```

---

## 입력 인터페이스 통합 설계

### 통합 설정 클래스 구조

```python
from dataclasses import dataclass
from typing import List, Optional
from enum import Enum

class CapacityMode(Enum):
    """용량 설정 모드"""
    AUTO_CRATE = "auto_crate"  # C-rate 기반 자동 감지
    MANUAL = "manual"  # 수동 입력

class DCIRMode(Enum):
    """DCIR 측정 모드"""
    STANDARD = "standard"  # SOC100 10s 방전 펄스
    PULSE = "pulse"  # SOC5, 50 10s 방전 펄스
    RSS = "rss"  # SOC 30/50/70 충/방전 1s 펄스/RSS

class ProfileLayout(Enum):
    """Profile 그래프 레이아웃"""
    BY_CYCLE = "by_cycle"  # 사이클 통합
    BY_CELL = "by_cell"  # 셀별 통합

@dataclass
class PathConfig:
    """경로 설정"""
    use_tsv: bool = True
    tsv_file: Optional[str] = None
    manual_paths: Optional[List[str]] = None
    folder_paths: Optional[List[str]] = None

@dataclass
class CapacityConfig:
    """용량 설정"""
    mode: CapacityMode = CapacityMode.AUTO_CRATE
    c_rate: float = 0.2
    manual_capacity: float = 58.0  # mAh

@dataclass
class CycleConfig:
    """Cycle 분석 설정"""
    cycle_numbers: List[int] = None  # [2, 3, 4, ...]
    cycle_range: Optional[tuple] = None  # (start, end) for continuous
    x_max: float = 0  # 0 = auto
    y_max: float = 1.10
    y_min: float = 0.65
    dcir_mode: DCIRMode = DCIRMode.RSS
    dcir_scale: float = 0  # 0 = auto

@dataclass
class ProfileConfig:
    """Profile 분석 설정"""
    cycle_numbers: List[int] = None
    cycle_range: Optional[tuple] = None
    layout: ProfileLayout = ProfileLayout.BY_CYCLE

    # 전압 축
    voltage_min: float = 2.5
    voltage_max: float = 4.7
    voltage_gap: float = 0.1

    # dQ/dV 파라미터
    smoothing: int = 0  # 0 = auto
    cutoff_crate: float = 0
    dqdv_scale: float = 1.0
    swap_dqdv_axes: bool = False

@dataclass
class ExportConfig:
    """내보내기 설정"""
    save_excel: bool = False
    save_ect: bool = False
    save_figure: bool = False
    excel_filename: Optional[str] = None
    ect_filename: Optional[str] = None
    figure_filename: Optional[str] = None

@dataclass
class AnalysisConfig:
    """전체 분석 설정 통합"""
    path: PathConfig
    capacity: CapacityConfig
    cycle: Optional[CycleConfig] = None
    profile: Optional[ProfileConfig] = None
    export: ExportConfig = None

    def validate(self):
        """설정 검증"""
        # 경로 검증
        if self.path.use_tsv and not self.path.tsv_file:
            raise ValueError("TSV 모드 활성화 시 TSV 파일 필요")

        # 용량 검증
        if self.capacity.mode == CapacityMode.AUTO_CRATE:
            if self.capacity.c_rate <= 0:
                raise ValueError("C-rate는 0보다 커야 함")
        elif self.capacity.mode == CapacityMode.MANUAL:
            if self.capacity.manual_capacity <= 0:
                raise ValueError("용량은 0보다 커야 함")

        # 사이클 번호 검증
        if self.cycle and self.cycle.cycle_numbers:
            if not all(c > 0 for c in self.cycle.cycle_numbers):
                raise ValueError("사이클 번호는 양수여야 함")

        # Profile 파라미터 검증
        if self.profile:
            if self.profile.voltage_min >= self.profile.voltage_max:
                raise ValueError("전압 최소값이 최대값보다 작아야 함")
```

### 설정 빌더 패턴

```python
class AnalysisConfigBuilder:
    """설정 빌더 - GUI에서 설정 생성"""

    def __init__(self):
        self.config = AnalysisConfig(
            path=PathConfig(),
            capacity=CapacityConfig(),
            export=ExportConfig()
        )

    def from_gui_widgets(self, gui):
        """GUI 위젯에서 설정 생성"""

        # 경로 설정
        self.config.path = PathConfig(
            use_tsv=gui.chk_cyclepath.isChecked(),
            tsv_file=self._get_tsv_file(gui) if gui.chk_cyclepath.isChecked() else None,
            manual_paths=gui.stepnum_2.toPlainText().split('\n') if gui.stepnum_2.toPlainText() else None
        )

        # 용량 설정
        if gui.inicaprate.isChecked():
            self.config.capacity = CapacityConfig(
                mode=CapacityMode.AUTO_CRATE,
                c_rate=float(gui.ratetext.text())
            )
        else:
            self.config.capacity = CapacityConfig(
                mode=CapacityMode.MANUAL,
                manual_capacity=float(gui.capacitytext.text())
            )

        # 내보내기 설정
        self.config.export = ExportConfig(
            save_excel=gui.saveok.isChecked(),
            save_ect=gui.ect_saveok.isChecked(),
            save_figure=gui.figsaveok.isChecked()
        )

        return self

    def with_cycle_config(self, gui):
        """Cycle 분석 설정 추가"""

        dcir_mode = DCIRMode.RSS
        if gui.dcirchk.isChecked():
            dcir_mode = DCIRMode.STANDARD
        elif gui.pulsedcir.isChecked():
            dcir_mode = DCIRMode.PULSE

        self.config.cycle = CycleConfig(
            cycle_numbers=convert_steplist(gui.stepnum.toPlainText()),
            x_max=float(gui.tcyclerng.text()),
            y_max=float(gui.tcyclerngyhl.text()),
            y_min=float(gui.tcyclerngyll.text()),
            dcir_mode=dcir_mode,
            dcir_scale=float(gui.dcirscale.text())
        )

        return self

    def with_profile_config(self, gui):
        """Profile 분석 설정 추가"""

        layout = ProfileLayout.BY_CYCLE if gui.CycProfile.isChecked() else ProfileLayout.BY_CELL

        cycle_input = gui.stepnum.toPlainText()
        if "-" in cycle_input:
            # 연속 범위
            start, end = map(int, cycle_input.strip().split("-"))
            cycle_range = (start, end)
            cycle_numbers = None
        else:
            # 개별 사이클
            cycle_range = None
            cycle_numbers = convert_steplist(cycle_input)

        self.config.profile = ProfileConfig(
            cycle_numbers=cycle_numbers,
            cycle_range=cycle_range,
            layout=layout,
            voltage_min=float(gui.volrngyhl.text()),
            voltage_max=float(gui.volrngyll.text()),
            voltage_gap=float(gui.volrnggap.text()),
            smoothing=int(gui.smooth.text()),
            cutoff_crate=float(gui.cutoff.text()),
            dqdv_scale=float(gui.dqdvscale.text()),
            swap_dqdv_axes=gui.chk_dqdv.isChecked()
        )

        return self

    def build(self):
        """설정 빌드 및 검증"""
        self.config.validate()
        return self.config
```

---

## 입력 파라미터 요약표

### Cycle 분석 파라미터

| 파라미터 | 위젯 | 기본값 | 설명 |
|---------|------|--------|------|
| C-rate | ratetext | 0.2 | 기준 C-rate |
| 용량 (mAh) | capacitytext | 58 | 수동 입력 용량 |
| 사이클 번호 | stepnum | "2" | 분석할 사이클 |
| X축 최대 | tcyclerng | 0 | 0=자동 |
| Y축 최대 | tcyclerngyhl | 1.10 | 용량 비율 상한 |
| Y축 최소 | tcyclerngyll | 0.65 | 용량 비율 하한 |
| DCIR 모드 | dcirchk/pulsedcir/mkdcir | RSS | 3가지 측정 방식 |
| DCIR 스케일 | dcirscale | 0 | 0=자동 |

### Profile 분석 파라미터

| 파라미터 | 위젯 | 기본값 | 설명 |
|---------|------|--------|------|
| 사이클 번호 | stepnum | "2" | 분석할 사이클/범위 |
| 레이아웃 | CycProfile/CellProfile | 사이클 | 그래프 배치 방식 |
| 전압 하한 (V) | volrngyhl | 2.5 | Y축 하한 |
| 전압 상한 (V) | volrngyll | 4.7 | Y축 상한 |
| 전압 간격 (V) | volrnggap | 0.1 | Y축 눈금 간격 |
| Smoothing | smooth | 0 | 0=자동 (데이터/30) |
| Cutoff C-rate | cutoff | 0 | 필터링 임계값 |
| dQ/dV 스케일 | dqdvscale | 1 | 축 스케일 배율 |
| dQ/dV 축 교환 | chk_dqdv | False | X/Y 축 바꾸기 |

### 내보내기 파라미터

| 파라미터 | 위젯 | 기본값 | 설명 |
|---------|------|--------|------|
| Excel 저장 | saveok | False | .xlsx 파일 생성 |
| ECT 저장 | ect_saveok | False | ECT 형식 CSV |
| 그래프 저장 | figsaveok | False | PNG/PDF 저장 |

---

## 크로스체크 검증 항목

### 입력 처리 검증

#### 경로 입력
- [ ] 다중 폴더 선택: 선택된 경로 개수 일치
- [ ] TSV 파일 로드: cyclepath, cyclename 파싱 일치
- [ ] 수동 경로 입력: 줄바꿈 구분 처리 일치
- [ ] 사이클러 자동 감지: PNE/Toyo 판별 일치

#### 용량 설정
- [ ] 자동 감지 (C-rate): 계산된 용량 일치
- [ ] 파일명 추출: name_capacity() 결과 일치
- [ ] 수동 입력: 입력값 적용 일치

#### 사이클 번호 파싱
- [ ] 개별 숫자: "3 4 5" → [3,4,5] 일치
- [ ] 범위 표기: "8-9" → [8,9] 일치
- [ ] 혼합: "3 4 5 8-9" → [3,4,5,8,9] 일치
- [ ] 연속 범위: "3-5" → range(3,6) 처리 일치

#### Profile 파라미터
- [ ] Smoothing 자동 계산: len/30 공식 일치
- [ ] dQ/dV 계산: smoothing 적용 결과 일치
- [ ] 축 교환 옵션: chk_dqdv 동작 일치

#### 내보내기
- [ ] Excel: 파일 생성 및 구조 일치
- [ ] ECT CSV: Time/Voltage/Current/Temp 포맷 일치
- [ ] 그래프: 이미지 파일 생성 일치

---

## 결론

### 핵심 포인트
1. **150+ 입력 위젯**을 **5개 설정 클래스**로 통합 가능
2. **데이터클래스 + 빌더 패턴**으로 GUI 의존성 분리
3. **검증 로직**을 설정 클래스에 통합하여 일관성 보장
4. **크로스체크**로 원본과 동일한 입력 처리 검증

### 통합 효과
- 코드 중복 감소: 입력 처리 로직 중앙화
- 유지보수성 향상: 설정 변경 시 단일 지점 수정
- 테스트 용이: 설정 객체 단위 테스트 가능
- 확장성: 새로운 파라미터 추가 용이

### 다음 단계
- 아키텍처 설계 문서 작성
- Data Loader 상세 설계
- 확장 기능 설계 (Toyo DCIR, Profile 연속성)
