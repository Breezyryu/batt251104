# 확장 기능 상세 설계

## 개요

원본 BatteryDataTool.py에 없거나 부분적으로만 구현된 **2가지 핵심 확장 기능**의 상세 설계 문서입니다:
1. **Toyo DCIR 구현** - 현재 PNE만 지원, Toyo 추가 필요
2. **Profile 연속 경로 지원** - Step/방전/율변에 연속 범위 처리 추가

---

## 1. Toyo DCIR 구현

### 1.1 현재 상태

**PNE DCIR (이미 구현됨)**:
```python
# dcir_confirm_button() - line 9813
if not check_cycler(cyclefolder):  # Toyo
    err_msg("PNE 충방전기 사용 요청",
            "DCIR은 PNE 충방전기를 사용하여 측정 부탁 드립니다.")
    continue  # Toyo 차단
else:  # PNE
    temp = pne_dcir_Profile_data(FolderBase, Step_CycNo, Step_CycEnd,
                                  mincapacity, firstCrate)
```

**PNE DCIR 측정 원리**:
```python
# pne_dcir_Profile_data() - line 1685

# 1. 20초 펄스 종료점 감지
dcir_base = Profileraw.loc[Profileraw["StepTime"] == 20]

# 2. 4개 펄스 전류 추출
Curr1, Curr2, Curr3, Curr4 = dcir_base["Curr"].values[:4]

# 3. 특정 시간대 전압 추출 (0.0s, 0.2s, 1.0s, 10.0s, 20.0s)
times = [0.0, 0.2, 1.0, 10.0, 20.0]

# 4. DCIR 계산
DCIR_0_1s = (V_rest - V_0_1s) / Current  # mΩ
DCIR_1s = (V_rest - V_1s) / Current
DCIR_10s = (V_rest - V_10s) / Current
DCIR_20s = (V_rest - V_20s) / Current
DCIR_RSS = sqrt(DCIR_10s^2 + DCIR_1s^2)

# 5. SOC별 저장
# SOC: [0, 5, 10, 15, ..., 95, 100]
# 각 SOC에서 5가지 DCIR 값
```

### 1.2 Toyo 데이터 구조 분석

**PNE vs Toyo 차이점**:

| 항목 | PNE | Toyo |
|------|-----|------|
| **시간 컬럼** | `StepTime` (단계별 경과 시간) | `Time` (절대 시간) |
| **상태 표현** | Step 번호 | `Condition` (0=휴지, 1=충전, 2=방전) |
| **펄스 감지** | `StepTime == 20` | Condition 변화 + 시간 차이 |
| **전류 방향** | 양수/음수 | Condition으로 구분 |

**Toyo Condition 기반 펄스 감지**:
```
시간(s)  Condition  Voltage  Current  설명
----------------------------------------------
0        0          3.8      0        휴지 (OCV)
1        2          3.7      -2000    방전 펄스 시작
2        2          3.65     -2000    방전 중 (0.2s)
3        2          3.6      -2000    방전 중 (1.0s)
10       2          3.55     -2000    방전 중 (10.0s)
20       2          3.5      -2000    방전 중 (20.0s)
21       0          3.75     0        휴지 복귀 (CCV)
```

### 1.3 Toyo DCIR 구현 설계

#### 1.3.1 ToyoDCIRProcessor 클래스

```python
# extensions/toyo_dcir.py

import pandas as pd
import numpy as np
from typing import Dict, List, Tuple

class ToyoDCIRProcessor:
    """
    Toyo 사이클러용 DCIR 계산 프로세서

    Methodology:
        1. Condition 변화로 펄스 구간 감지
        2. 시간 차이 계산으로 0.2s, 1s, 10s, 20s 지점 추출
        3. OCV/CCV 추출 (펄스 전/후 휴지 전압)
        4. DCIR 계산 (5가지 시간 스케일)
        5. SOC별 저장
    """

    def __init__(self):
        self.pulse_times = [0.0, 0.2, 1.0, 10.0, 20.0]  # 초

    def calculate(
        self,
        data: pd.DataFrame,
        capacity: float
    ) -> pd.DataFrame:
        """
        Toyo 데이터에서 DCIR 계산

        Args:
            data: Toyo 사이클 데이터
            capacity: 배터리 용량 (mAh)

        Returns:
            SOC별 DCIR DataFrame
            컬럼: [SOC, OCV, CCV, DCIR_0_1s, DCIR_1s, DCIR_10s, DCIR_20s, DCIR_RSS]
        """
        # 1. 펄스 구간 감지
        pulse_segments = self._detect_pulse_segments(data)

        # 2. 각 펄스에서 DCIR 계산
        dcir_results = []
        for segment in pulse_segments:
            dcir_data = self._calculate_pulse_dcir(segment, capacity)
            if dcir_data:
                dcir_results.append(dcir_data)

        # 3. DataFrame 생성
        df = pd.DataFrame(dcir_results)

        return df

    def _detect_pulse_segments(
        self,
        data: pd.DataFrame
    ) -> List[pd.DataFrame]:
        """
        Condition 변화로 펄스 구간 감지

        Logic:
            - 펄스 시작: Condition 0 → 2 (휴지 → 방전)
            - 펄스 종료: Condition 2 → 0 (방전 → 휴지)
            - 20초 이상 지속되는 펄스만 선택
        """
        segments = []
        condition = data['Condition'].values
        time = data['Time'].values

        in_pulse = False
        pulse_start_idx = None

        for i in range(1, len(condition)):
            prev_cond = condition[i - 1]
            curr_cond = condition[i]

            # 펄스 시작 감지
            if prev_cond == 0 and curr_cond == 2:
                in_pulse = True
                pulse_start_idx = i - 1  # 휴지 상태 포함

            # 펄스 종료 감지
            elif prev_cond == 2 and curr_cond == 0:
                if in_pulse and pulse_start_idx is not None:
                    pulse_end_idx = i

                    # 펄스 지속 시간 확인
                    pulse_duration = time[pulse_end_idx] - time[pulse_start_idx]

                    if pulse_duration >= 20:  # 20초 이상
                        segment = data.iloc[pulse_start_idx:pulse_end_idx + 1].copy()
                        segments.append(segment)

                in_pulse = False
                pulse_start_idx = None

        return segments

    def _calculate_pulse_dcir(
        self,
        segment: pd.DataFrame,
        capacity: float
    ) -> Dict:
        """
        단일 펄스에서 DCIR 계산

        Args:
            segment: 펄스 구간 데이터 (휴지 → 방전 → 휴지)
            capacity: 배터리 용량

        Returns:
            {SOC, OCV, CCV, DCIR_0_1s, DCIR_1s, DCIR_10s, DCIR_20s, DCIR_RSS}
        """
        # 1. 펄스 시작/종료 찾기
        condition = segment['Condition'].values
        pulse_start = np.where(condition == 2)[0][0]  # 방전 시작
        pulse_end = np.where(condition == 2)[0][-1]   # 방전 종료

        # 2. OCV/CCV 추출
        ocv = segment.iloc[pulse_start - 1]['Voltage']  # 휴지 전압 (펄스 직전)
        ccv = segment.iloc[pulse_end + 1]['Voltage']   # 휴지 전압 (펄스 직후)

        # 3. 펄스 전류 (절대값)
        pulse_current = abs(segment.iloc[pulse_start]['Current'])  # mA

        # 4. 펄스 시작 시간 기준점
        time_col = segment['Time'].values
        pulse_start_time = time_col[pulse_start]

        # 5. 각 시간대 전압 추출
        voltages = {}
        for t in self.pulse_times:
            target_time = pulse_start_time + t
            # 가장 가까운 시간 찾기
            idx = np.argmin(np.abs(time_col - target_time))
            voltages[t] = segment.iloc[idx]['Voltage']

        # 6. DCIR 계산 (mΩ)
        dcir_0_1s = (ocv - voltages[0.2]) / pulse_current * 1000  # mV/mA = mΩ
        dcir_1s = (ocv - voltages[1.0]) / pulse_current * 1000
        dcir_10s = (ocv - voltages[10.0]) / pulse_current * 1000
        dcir_20s = (ocv - voltages[20.0]) / pulse_current * 1000

        # RSS (Root Sum Square)
        dcir_rss = np.sqrt(dcir_10s**2 + dcir_1s**2)

        # 7. SOC 계산 (누적 용량 기반)
        # 방전 시작 시점의 누적 용량
        accumulated_capacity = segment.iloc[pulse_start]['Capacity']  # mAh
        soc = (1 - accumulated_capacity / capacity) * 100  # %

        return {
            'SOC': soc,
            'OCV': ocv,
            'CCV': ccv,
            'DCIR_0_1s': dcir_0_1s,
            'DCIR_1s': dcir_1s,
            'DCIR_10s': dcir_10s,
            'DCIR_20s': dcir_20s,
            'DCIR_RSS': dcir_rss
        }
```

#### 1.3.2 DCIRProfileStrategy 통합

```python
# analysis/strategies/profile_strategies.py

class DCIRProfileStrategy(BaseAnalysisStrategy):
    """DCIR 프로파일 전략 (PNE + Toyo 지원)"""

    def analyze(self, container: CycleDataContainer) -> AnalysisResult:
        """DCIR 분석 (사이클러 타입 자동 감지)"""

        config = self.config.profile_config
        cycler_type = container.cycler_type

        # 연속 범위 처리
        if config.cycle_range:
            start, end = config.cycle_range
            data = container.get_cycle_range(start, end)
        else:
            data = container.get_cycle(config.cycle_numbers[0])

        # 사이클러별 DCIR 계산
        if cycler_type == "pne":
            from ..processors.dcir_processor import PNEDCIRProcessor
            processor = PNEDCIRProcessor()
        elif cycler_type == "toyo":
            from extensions.toyo_dcir import ToyoDCIRProcessor
            processor = ToyoDCIRProcessor()
        else:
            raise ValueError(f"Unknown cycler type: {cycler_type}")

        dcir_data = processor.calculate(data, container.capacity)

        return AnalysisResult(
            data=dcir_data,
            subplot_count=4,
            layout_type="dcir_profile"
        )

    def get_subplot_count(self) -> int:
        return 4

    def get_data_attr(self) -> str:
        return "dcir"
```

### 1.4 검증 계획

#### 1.4.1 단위 테스트

```python
# tests/test_toyo_dcir.py

import pytest
from extensions.toyo_dcir import ToyoDCIRProcessor

def test_pulse_detection():
    """Condition 변화로 펄스 감지 테스트"""
    # Mock Toyo data
    data = create_mock_toyo_pulse_data()

    processor = ToyoDCIRProcessor()
    segments = processor._detect_pulse_segments(data)

    assert len(segments) > 0
    assert all(seg['Condition'].iloc[0] == 0 for seg in segments)  # 시작은 휴지

def test_dcir_calculation():
    """DCIR 계산 정확도 테스트"""
    segment = create_single_pulse_segment()

    processor = ToyoDCIRProcessor()
    result = processor._calculate_pulse_dcir(segment, capacity=4500)

    # 예상값과 비교 (수동 계산)
    assert 'DCIR_0_1s' in result
    assert result['DCIR_0_1s'] > 0
    assert result['OCV'] > result['CCV']  # OCV > CCV
```

#### 1.4.2 크로스체크

**검증 항목**:
- [ ] Toyo 데이터에서 펄스 감지: 개수 및 위치 정확
- [ ] OCV/CCV 추출: 휴지 전압 정확
- [ ] 시간별 전압 추출: 0.2s, 1s, 10s, 20s 지점 정확
- [ ] DCIR 계산: 5가지 값 모두 정확 (±0.01 mΩ)
- [ ] SOC 계산: 누적 용량 기반 정확
- [ ] 그래프 출력: 4 subplot 레이아웃 일치

---

## 2. Profile 연속 경로 지원

### 2.1 현재 상태

**DCIR만 연속 지원**:
```python
# dcir_confirm_button() - line 9813
if "-" in self.stepnum.toPlainText():
    Step_CycNo, Step_CycEnd = map(int, cycle_range.split("-"))
    # 연속 범위 처리
```

**Step/Rate/Chg/Dchg는 개별만 지원**:
```python
# step_confirm_button() - line 8833
for Step_CycNo in CycleNo:  # [3, 4, 5, 8, 9]
    temp = pne_step_Profile_data(FolderBase, Step_CycNo, ...)
    # 개별 사이클만 처리
```

### 2.2 설계 목표

**사용자 입력 형식 통합**:
```
개별: "3 4 5 8 9" → [3, 4, 5, 8, 9]
범위: "3-5" → 사이클 3, 4, 5를 연속 데이터로 병합
혼합: "3 4 5 8-10" → [3, 4, 5] + range(8, 11)
```

**모든 Profile 함수에 적용**:
- ✅ DCIR: 이미 지원
- 🔨 Step: 추가 필요
- 🔨 Rate: 추가 필요
- 🔨 Charge: 추가 필요
- 🔨 Discharge: 추가 필요

### 2.3 설계 방안

#### 2.3.1 사이클 입력 파서

```python
# utils/cycle_utils.py

from typing import Union, List, Tuple

class CycleInputParser:
    """
    사이클 번호 입력 파싱

    Formats:
        - "3 4 5" → discrete: [3, 4, 5]
        - "3-5" → continuous: (3, 5)
        - "3 4 5 8-10" → mixed: [3, 4, 5] + range(8, 11)
    """

    @staticmethod
    def parse(input_str: str) -> Tuple[str, Union[List[int], Tuple[int, int]]]:
        """
        사이클 입력 파싱

        Args:
            input_str: 사용자 입력 ("3 4 5" 또는 "3-5")

        Returns:
            (mode, data) tuple
            - mode: "discrete" or "continuous"
            - data: List[int] or (start, end)
        """
        input_str = input_str.strip()

        # 연속 범위 감지 (공백 없이 - 하나만)
        if "-" in input_str and " " not in input_str:
            # 연속 모드: "3-5"
            start, end = map(int, input_str.split("-"))
            return "continuous", (start, end)

        # 개별 또는 혼합 모드
        tokens = input_str.split()

        cycle_list = []
        for token in tokens:
            if "-" in token:
                # 범위 확장: "8-10" → [8, 9, 10]
                start, end = map(int, token.split("-"))
                cycle_list.extend(range(start, end + 1))
            else:
                # 개별 번호
                cycle_list.append(int(token))

        return "discrete", cycle_list

    @staticmethod
    def validate(input_str: str) -> bool:
        """입력 형식 검증"""
        try:
            mode, data = CycleInputParser.parse(input_str)
            return True
        except Exception:
            return False
```

#### 2.3.2 연속 프로파일 프로세서

```python
# extensions/continuous_profile.py

import pandas as pd
from typing import Tuple

class ContinuousProfileProcessor:
    """
    연속 사이클 범위 프로파일 처리

    Purpose:
        - 여러 사이클을 하나의 연속 데이터로 병합
        - OCV/CCV 계산
        - 시간축 연속성 보장
    """

    def __init__(self, container: 'CycleDataContainer'):
        self.container = container

    def process_continuous_range(
        self,
        start: int,
        end: int,
        profile_type: str
    ) -> Tuple[float, pd.DataFrame]:
        """
        연속 범위 처리

        Args:
            start: 시작 사이클 번호
            end: 종료 사이클 번호
            profile_type: "step", "rate", "charge", "discharge"

        Returns:
            (capacity, merged_dataframe)
        """
        # 1. 범위 내 모든 사이클 조회
        merged = self.container.get_cycle_range(start, end)

        # 2. 시간축 조정 (연속성 보장)
        merged = self._adjust_time_continuity(merged)

        # 3. OCV/CCV 계산 (필요 시)
        if profile_type in ["charge", "discharge"]:
            merged = self._calculate_ocv_ccv(merged)

        # 4. 용량
        capacity = self.container.capacity

        return capacity, merged

    def _adjust_time_continuity(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        시간축 연속성 조정

        Problem:
            각 사이클은 Time=0에서 시작
            → 병합 시 시간 겹침

        Solution:
            누적 시간으로 변환
        """
        df = df.copy()

        # 사이클 경계 감지 (Time이 감소하는 지점)
        time_col = df['Time'].values
        boundaries = [0]  # 첫 사이클 시작

        for i in range(1, len(time_col)):
            if time_col[i] < time_col[i - 1]:
                boundaries.append(i)

        # 각 구간별 시간 오프셋 적용
        time_offset = 0
        for i in range(len(boundaries)):
            start_idx = boundaries[i]
            end_idx = boundaries[i + 1] if i + 1 < len(boundaries) else len(df)

            # 현재 구간 시간에 오프셋 추가
            df.loc[start_idx:end_idx - 1, 'Time'] += time_offset

            # 다음 구간 오프셋 업데이트
            if end_idx < len(df):
                time_offset = df.loc[end_idx - 1, 'Time']

        return df

    def _calculate_ocv_ccv(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        OCV/CCV 계산 및 컬럼 추가

        Logic:
            - 휴지 구간 (Current == 0) → OCV
            - 부하 구간 (Current != 0) → CCV
        """
        df = df.copy()

        df['OCV'] = 0.0
        df['CCV'] = 0.0

        is_rest = df['Current'].abs() < 0.001  # mA (휴지 판정)

        df.loc[is_rest, 'OCV'] = df.loc[is_rest, 'Voltage']
        df.loc[~is_rest, 'CCV'] = df.loc[~is_rest, 'Voltage']

        return df
```

#### 2.3.3 ProfileAnalysisConfig 업데이트

```python
# config/analysis_config.py

@dataclass
class ProfileAnalysisConfig:
    """Profile 분석 설정"""

    # 기존 필드
    cycle_numbers: Optional[List[int]] = None
    cycle_range: Optional[Tuple[int, int]] = None  # (start, end) for continuous
    layout: ProfileLayout = ProfileLayout.BY_CYCLE

    # ... 기타 필드 ...

    @classmethod
    def from_input(cls, cycle_input: str, **kwargs):
        """
        사용자 입력에서 설정 생성

        Args:
            cycle_input: "3 4 5" 또는 "3-5"
            **kwargs: 기타 설정 파라미터
        """
        from utils.cycle_utils import CycleInputParser

        mode, data = CycleInputParser.parse(cycle_input)

        if mode == "continuous":
            start, end = data
            return cls(
                cycle_numbers=None,
                cycle_range=(start, end),
                **kwargs
            )
        else:  # discrete
            return cls(
                cycle_numbers=data,
                cycle_range=None,
                **kwargs
            )
```

#### 2.3.4 Strategy 통합

```python
# analysis/strategies/profile_strategies.py

class StepProfileStrategy(BaseAnalysisStrategy):
    """충전 Step 프로파일 전략 (연속 지원)"""

    def analyze(self, container: CycleDataContainer) -> AnalysisResult:
        """Step charge 프로파일 분석"""

        config = self.config.profile_config

        # 연속 vs 개별 처리
        if config.cycle_range:
            # 연속 모드
            from extensions.continuous_profile import ContinuousProfileProcessor

            processor = ContinuousProfileProcessor(container)
            capacity, data = processor.process_continuous_range(
                start=config.cycle_range[0],
                end=config.cycle_range[1],
                profile_type="step"
            )

            results = [{'capacity': capacity, 'data': data}]

        else:
            # 개별 모드
            results = []
            for cycle_no in config.cycle_numbers:
                cycle_data = container.get_cycle(cycle_no)
                results.append({
                    'cycle_no': cycle_no,
                    'data': cycle_data
                })

        return AnalysisResult(
            data=results,
            subplot_count=6,
            layout_type="step_profile"
        )
```

### 2.4 구현 우선순위

#### Priority 1: 기반 유틸리티
1. ✅ CycleInputParser 구현
2. ✅ ContinuousProfileProcessor 구현

#### Priority 2: Strategy 업데이트
1. StepProfileStrategy - 연속 지원 추가
2. RateProfileStrategy - 연속 지원 추가
3. ChargeProfileStrategy - 연속 지원 추가
4. DischargeProfileStrategy - 연속 지원 추가

#### Priority 3: 검증
1. 단위 테스트 작성
2. 크로스체크 검증

### 2.5 검증 계획

#### 2.5.1 단위 테스트

```python
# tests/test_continuous_profile.py

def test_cycle_input_parser():
    """사이클 입력 파싱 테스트"""
    # 개별
    mode, data = CycleInputParser.parse("3 4 5")
    assert mode == "discrete"
    assert data == [3, 4, 5]

    # 연속
    mode, data = CycleInputParser.parse("3-5")
    assert mode == "continuous"
    assert data == (3, 5)

    # 혼합
    mode, data = CycleInputParser.parse("3 4 5 8-10")
    assert mode == "discrete"
    assert data == [3, 4, 5, 8, 9, 10]

def test_time_continuity():
    """시간축 연속성 테스트"""
    # Mock 데이터: 3개 사이클 (각각 Time 0부터 시작)
    df = create_mock_merged_cycles()

    processor = ContinuousProfileProcessor(None)
    adjusted = processor._adjust_time_continuity(df)

    # 시간이 연속적으로 증가하는지 확인
    assert (adjusted['Time'].diff()[1:] >= 0).all()
```

#### 2.5.2 크로스체크

**검증 항목**:
- [ ] 연속 입력 파싱: "3-5" → (3, 5) 정확
- [ ] 사이클 병합: 3개 사이클 데이터 연속성 확인
- [ ] 시간축 조정: 누적 시간 정확
- [ ] OCV/CCV 계산: 휴지/부하 전압 정확
- [ ] 그래프 출력: 연속 데이터 플롯 일치
- [ ] Excel 내보내기: 병합 데이터 구조 일치

---

## 3. 통합 사용 예제

### 예제 1: Toyo DCIR 분석

```python
from battery_analyzer import BatteryAnalyzer, AnalysisConfig
from battery_analyzer.config import PathConfig, CapacityConfig, ProfileAnalysisConfig

# 설정
config = AnalysisConfig(
    path=PathConfig(
        paths=["Rawdata/Q7M Sub ATL [45v 2068mAh] [23] - 250219r"]
    ),
    capacity=CapacityConfig(
        mode=CapacityMode.AUTO_CRATE,
        c_rate=0.2
    ),
    profile_config=ProfileAnalysisConfig.from_input(
        cycle_input="3-5",  # 연속 범위
        voltage_min=2.5,
        voltage_max=4.7
    )
)

# 분석 실행
analyzer = BatteryAnalyzer(config)
analyzer.load_data(config.path.paths[0])  # Toyo 자동 감지

from battery_analyzer.analysis.strategies import DCIRProfileStrategy
analyzer.set_strategy(DCIRProfileStrategy(config))

result = analyzer.analyze()  # Toyo DCIR 자동 처리
fig = analyzer.visualize(result)
```

### 예제 2: Profile 연속 경로 분석

```python
# Step charge 연속 범위 분석
config = AnalysisConfig(
    path=PathConfig(paths=["Rawdata/A1_MP1_4500mAh_T23_3"]),
    capacity=CapacityConfig(mode=CapacityMode.MANUAL, manual_capacity=4500),
    profile_config=ProfileAnalysisConfig.from_input(
        cycle_input="10-20",  # 사이클 10-20 연속 처리
        voltage_min=2.5,
        voltage_max=4.7
    )
)

analyzer = BatteryAnalyzer(config)
analyzer.load_data(config.path.paths[0])

from battery_analyzer.analysis.strategies import StepProfileStrategy
analyzer.set_strategy(StepProfileStrategy(config))

result = analyzer.analyze()  # 연속 범위 자동 병합
fig = analyzer.visualize(result)
```

---

## 4. 구현 로드맵

### Phase 1: Toyo DCIR (우선순위 높음)
- [ ] Week 1: ToyoDCIRProcessor 구현
- [ ] Week 2: DCIRProfileStrategy 통합
- [ ] Week 3: 단위 테스트 및 크로스체크
- [ ] Week 4: 문서화 및 예제

### Phase 2: Profile 연속 경로
- [ ] Week 5: CycleInputParser 구현
- [ ] Week 6: ContinuousProfileProcessor 구현
- [ ] Week 7: 4가지 Strategy 업데이트
- [ ] Week 8: 단위 테스트 및 크로스체크

### Phase 3: 통합 검증
- [ ] Week 9: 전체 크로스체크 (4개 테스트 케이스)
- [ ] Week 10: 성능 최적화 및 버그 수정

---

## 5. 크로스체크 종합 검증

### 테스트 케이스

**1. Toyo 연속 경로 (4개)**
```
Input:
  - 250207_250307_3_김동진_1689mAh_ATL Q7M Inner 2C 상온수명 1-100cyc
  - 250219_250319_3_김동진_1689mAh_ATL Q7M Inner 2C 상온수명 101-200cyc
  - 250304_250404_3_김동진_1689mAh_ATL Q7M Inner 2C 상온수명 201-300cyc
  - 250317_251231_3_김동진_1689mAh_ATL Q7M Inner 2C 상온수명 301-400cyc

Tests:
  - [ ] Linked Cycle: 400 사이클 연속 분석
  - [ ] Profile 연속: "10-20" 범위 처리
  - [ ] Toyo DCIR: "5-10" DCIR 분석
```

**2. PNE 연속 경로 (3개)**
```
Input:
  - A1_MP1_4500mAh_T23_1
  - A1_MP1_4500mAh_T23_2
  - A1_MP1_4500mAh_T23_3

Tests:
  - [ ] Linked Cycle: 3개 경로 연결
  - [ ] Profile 연속: "5-15" 범위 처리
  - [ ] DCIR: "3-8" DCIR 분석 (기존 기능)
```

**3. Toyo 단일 경로**
```
Input: Q7M Sub ATL [45v 2068mAh] [23] - 250219r

Tests:
  - [ ] Individual Cycle: 개별 사이클 분석
  - [ ] Toyo DCIR: "3-5" DCIR 분석 (신규)
  - [ ] Profile: Step/Rate/Chg/Dchg 모두 테스트
```

**4. PNE 단일 경로**
```
Input: A1_MP1_4500mAh_T23_3

Tests:
  - [ ] Individual Cycle: 개별 사이클 분석
  - [ ] DCIR: "2-4" DCIR 분석 (기존)
  - [ ] Profile 연속: "10-15" 범위 처리 (신규)
```

### 검증 기준

| 항목 | 허용 오차 | 검증 방법 |
|------|----------|----------|
| 펄스 감지 | 100% 일치 | 펄스 개수, 위치 비교 |
| DCIR 값 | ±0.01 mΩ | 5가지 시간 스케일 모두 |
| OCV/CCV | ±0.001 V | 휴지 전압 정확도 |
| 시간 연속성 | 단조 증가 | diff() >= 0 확인 |
| SOC 계산 | ±0.01% | 누적 용량 기반 |
| 그래프 | 100% 일치 | 데이터 포인트 개수, 값 |

---

## 결론

### 핵심 포인트
1. **Toyo DCIR**: Condition 기반 펄스 감지 + 시간 차이 계산
2. **Profile 연속성**: 사이클 범위 병합 + 시간축 조정
3. **통합 설계**: Strategy 패턴으로 확장 기능 자연스럽게 통합
4. **크로스체크**: 4개 테스트 케이스로 100% 일치 검증

### 다음 단계
- Phase 3: 실제 코드 구현
- Phase 4: 크로스체크 검증
- Phase 5: 최종 문서화 및 사용자 가이드

이 문서는 확장 기능 구현의 청사진을 제공합니다.
