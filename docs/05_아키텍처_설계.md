# 배터리 데이터 분석 도구 통합 아키텍처 설계

## 개요

BatteryDataTool.py에서 추출한 7가지 핵심 기능을 **compact하고 확장 가능한 아키텍처**로 재설계합니다.
**전체 사이클 1회 로드 후 필터링 구조**를 중심으로 70%+ 코드 중복을 제거합니다.

---

## 설계 원칙

### 1. 핵심 설계 원칙
1. **단일 책임 원칙 (SRP)**: 각 클래스는 하나의 명확한 책임
2. **개방-폐쇄 원칙 (OCP)**: 확장에는 열려있고 수정에는 닫혀있음
3. **의존성 역전 원칙 (DIP)**: 추상화에 의존, 구현에 의존하지 않음
4. **전략 패턴**: 분석 타입별 전략 객체로 분리
5. **팩토리 패턴**: 사이클러 타입별 로더 자동 생성

### 2. 성능 최적화 전략
- **전체 로드 + 필터링**: 사이클 데이터를 1회 로드 후 메모리에 캐싱
- **지연 평가**: 필요한 시점에만 데이터 처리
- **병렬 처리 가능**: 독립적인 분석은 병렬 실행 가능하도록 설계

### 3. 코드 품질 목표
- **코드 감소**: 10,000+ 라인 → 2,000-3,000 라인 (70%+ 감소)
- **중복 제거**: 공통 로직 통합으로 중복 최소화
- **테스트 가능**: 각 컴포넌트 단위 테스트 가능
- **문서화**: 명확한 API 문서 및 사용 예제

---

## 시스템 아키텍처

### 전체 구조도

```
┌─────────────────────────────────────────────────────────────┐
│                        사용자 인터페이스                      │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐       │
│  │ GUI (PyQt6)  │  │ CLI          │  │ API          │       │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘       │
└─────────┼──────────────────┼──────────────────┼──────────────┘
          │                  │                  │
          └──────────────────┼──────────────────┘
                             ▼
┌─────────────────────────────────────────────────────────────┐
│                    AnalysisConfig Builder                    │
│              (GUI → 설정 객체 변환)                           │
└──────────────────────────┬──────────────────────────────────┘
                           ▼
┌─────────────────────────────────────────────────────────────┐
│                    BatteryAnalyzer                           │
│                  (메인 분석 엔진)                             │
│  ┌─────────────────────────────────────────────────────┐    │
│  │ 1. 설정 검증                                         │    │
│  │ 2. DataLoader 생성 (Factory)                        │    │
│  │ 3. 전체 데이터 로드 → CycleDataContainer            │    │
│  │ 4. 분석 전략 선택 (Strategy)                        │    │
│  │ 5. 필터링 + 분석 실행                                │    │
│  │ 6. 그래프 생성 + 데이터 내보내기                      │    │
│  └─────────────────────────────────────────────────────┘    │
└───┬───────────────┬───────────────┬──────────────┬──────────┘
    │               │               │              │
    ▼               ▼               ▼              ▼
┌────────┐   ┌────────────┐   ┌──────────┐   ┌──────────┐
│ Config │   │DataLoader  │   │ Strategy │   │  Output  │
│ System │   │  Factory   │   │  Pattern │   │ Handlers │
└────────┘   └────────────┘   └──────────┘   └──────────┘
```

### 모듈 구조

```
battery_analyzer/
├── config/
│   ├── __init__.py
│   ├── analysis_config.py      # 설정 데이터클래스
│   └── config_builder.py       # GUI → 설정 변환
│
├── data/
│   ├── __init__.py
│   ├── data_container.py       # CycleDataContainer (메모리 캐싱)
│   ├── data_loader_base.py     # BaseDataLoader 추상 클래스
│   ├── pne_loader.py           # PNEDataLoader 구현
│   └── toyo_loader.py          # ToyoDataLoader 구현
│
├── analysis/
│   ├── __init__.py
│   ├── analyzer.py             # BatteryAnalyzer 메인 클래스
│   ├── strategies/
│   │   ├── __init__.py
│   │   ├── base_strategy.py   # 추상 전략 클래스
│   │   ├── cycle_strategies.py  # Cycle 분석 전략 (3종)
│   │   └── profile_strategies.py # Profile 분석 전략 (4종)
│   └── processors/
│       ├── __init__.py
│       ├── dqdv_processor.py   # dQ/dV 계산
│       └── dcir_processor.py   # DCIR 계산
│
├── visualization/
│   ├── __init__.py
│   ├── graph_builder.py        # 그래프 생성 템플릿
│   └── layouts.py              # 레이아웃 정의 (6subplot, 4subplot)
│
├── export/
│   ├── __init__.py
│   ├── excel_exporter.py       # Excel 내보내기
│   ├── csv_exporter.py         # CSV/ECT 내보내기
│   └── figure_exporter.py      # 그래프 이미지 저장
│
├── extensions/
│   ├── __init__.py
│   ├── toyo_dcir.py            # Toyo DCIR 구현
│   └── continuous_profile.py   # Profile 연속 경로 처리
│
├── utils/
│   ├── __init__.py
│   ├── path_utils.py           # 경로 처리 유틸
│   ├── cycle_utils.py          # 사이클 번호 파싱
│   └── validators.py           # 데이터 검증
│
└── ui/
    ├── __init__.py
    ├── main_window.py          # 메인 GUI (간소화)
    └── widgets.py              # 커스텀 위젯
```

---

## 핵심 컴포넌트 설계

### 1. 설정 시스템 (Config)

#### 1.1 설정 데이터클래스

```python
# config/analysis_config.py

from dataclasses import dataclass
from typing import List, Optional, Tuple
from enum import Enum

class CapacityMode(Enum):
    AUTO_CRATE = "auto_crate"
    MANUAL = "manual"

class DCIRMode(Enum):
    STANDARD = "standard"
    PULSE = "pulse"
    RSS = "rss"

class ProfileLayout(Enum):
    BY_CYCLE = "by_cycle"
    BY_CELL = "by_cell"

@dataclass
class PathConfig:
    """경로 설정"""
    paths: List[str]
    cycle_names: Optional[List[str]] = None
    use_tsv: bool = False
    tsv_file: Optional[str] = None

@dataclass
class CapacityConfig:
    """용량 설정"""
    mode: CapacityMode = CapacityMode.AUTO_CRATE
    c_rate: float = 0.2
    manual_capacity: float = 58.0

@dataclass
class CycleAnalysisConfig:
    """Cycle 분석 설정"""
    cycle_numbers: List[int]
    x_max: float = 0  # 0 = auto
    y_max: float = 1.10
    y_min: float = 0.65
    dcir_mode: DCIRMode = DCIRMode.RSS
    dcir_scale: float = 0

@dataclass
class ProfileAnalysisConfig:
    """Profile 분석 설정"""
    cycle_numbers: Optional[List[int]] = None
    cycle_range: Optional[Tuple[int, int]] = None  # (start, end) for continuous
    layout: ProfileLayout = ProfileLayout.BY_CYCLE

    # 전압 축
    voltage_min: float = 2.5
    voltage_max: float = 4.7
    voltage_gap: float = 0.1

    # dQ/dV
    smoothing: int = 0
    cutoff_crate: float = 0
    dqdv_scale: float = 1.0
    swap_dqdv_axes: bool = False

@dataclass
class ExportConfig:
    """내보내기 설정"""
    save_excel: bool = False
    save_ect: bool = False
    save_figure: bool = False

@dataclass
class AnalysisConfig:
    """전체 설정"""
    path: PathConfig
    capacity: CapacityConfig
    cycle_config: Optional[CycleAnalysisConfig] = None
    profile_config: Optional[ProfileAnalysisConfig] = None
    export: ExportConfig = None

    def validate(self):
        """설정 검증"""
        if not self.path.paths:
            raise ValueError("경로가 지정되지 않았습니다")

        if self.capacity.mode == CapacityMode.AUTO_CRATE:
            if self.capacity.c_rate <= 0:
                raise ValueError("C-rate는 0보다 커야 합니다")

        # 추가 검증 로직...
```

#### 1.2 설정 빌더

```python
# config/config_builder.py

class AnalysisConfigBuilder:
    """GUI → 설정 객체 변환"""

    def from_gui(self, gui) -> AnalysisConfig:
        """GUI 위젯에서 설정 생성"""

        path_config = self._build_path_config(gui)
        capacity_config = self._build_capacity_config(gui)
        export_config = self._build_export_config(gui)

        return AnalysisConfig(
            path=path_config,
            capacity=capacity_config,
            export=export_config
        )

    def _build_path_config(self, gui) -> PathConfig:
        """경로 설정 빌드"""
        if gui.chk_cyclepath.isChecked():
            # TSV 파일 기반
            tsv_file = self._get_tsv_file(gui)
            data = pd.read_csv(tsv_file, sep='\t')
            return PathConfig(
                paths=data['cyclepath'].tolist(),
                cycle_names=data['cyclename'].tolist(),
                use_tsv=True,
                tsv_file=tsv_file
            )
        else:
            # 다중 폴더 선택
            paths = self._get_folder_paths(gui)
            return PathConfig(paths=paths)

    # 기타 빌드 메서드...
```

---

### 2. 데이터 로딩 시스템 (Data)

#### 2.1 사이클 데이터 컨테이너

```python
# data/data_container.py

from typing import Dict, List, Optional
import pandas as pd

class CycleDataContainer:
    """전체 사이클 데이터 컨테이너 - 1회 로드 후 캐싱"""

    def __init__(self):
        self._all_cycles: Dict[int, pd.DataFrame] = {}
        self._metadata: Dict[str, any] = {}
        self._channels: List[str] = []

    def add_cycle(self, cycle_no: int, data: pd.DataFrame):
        """사이클 데이터 추가"""
        self._all_cycles[cycle_no] = data

    def get_cycle(self, cycle_no: int) -> pd.DataFrame:
        """단일 사이클 데이터 조회"""
        if cycle_no not in self._all_cycles:
            raise KeyError(f"Cycle {cycle_no} not found")
        return self._all_cycles[cycle_no]

    def get_cycle_range(self, start: int, end: int) -> pd.DataFrame:
        """사이클 범위 데이터 조회 및 병합"""
        dfs = []
        for cycle_no in range(start, end + 1):
            if cycle_no in self._all_cycles:
                dfs.append(self._all_cycles[cycle_no])

        if not dfs:
            raise ValueError(f"No cycles found in range {start}-{end}")

        return pd.concat(dfs, ignore_index=True)

    def get_cycles(self, cycle_list: List[int]) -> Dict[int, pd.DataFrame]:
        """여러 사이클 데이터 조회"""
        return {c: self._all_cycles[c] for c in cycle_list if c in self._all_cycles}

    def list_available_cycles(self) -> List[int]:
        """사용 가능한 사이클 번호 리스트"""
        return sorted(self._all_cycles.keys())

    def set_metadata(self, key: str, value: any):
        """메타데이터 설정"""
        self._metadata[key] = value

    def get_metadata(self, key: str) -> any:
        """메타데이터 조회"""
        return self._metadata.get(key)

    @property
    def capacity(self) -> float:
        """배터리 용량 (mAh)"""
        return self._metadata.get('capacity', 0)

    @property
    def channels(self) -> List[str]:
        """채널 리스트"""
        return self._channels
```

#### 2.2 데이터 로더 기본 클래스

```python
# data/data_loader_base.py

from abc import ABC, abstractmethod
from pathlib import Path

class BaseDataLoader(ABC):
    """데이터 로더 추상 기본 클래스"""

    @abstractmethod
    def load_all_cycles(self, path: str, config: CapacityConfig) -> CycleDataContainer:
        """전체 사이클 데이터 일괄 로드"""
        pass

    @staticmethod
    @abstractmethod
    def detect_cycler_type(path: str) -> bool:
        """사이클러 타입 감지"""
        pass

    def _extract_capacity(self, filepath: str, config: CapacityConfig) -> float:
        """용량 추출 (파일명 또는 설정)"""
        if config.mode == CapacityMode.MANUAL:
            return config.manual_capacity

        # 파일명에서 추출
        capacity = self._parse_capacity_from_filename(filepath)
        if capacity:
            return capacity

        # 첫 사이클 데이터에서 계산
        return self._calculate_capacity_from_first_cycle(filepath, config.c_rate)

    @staticmethod
    def _parse_capacity_from_filename(filepath: str) -> Optional[float]:
        """파일명에서 용량 파싱 (예: 58mAh)"""
        import re
        match = re.search(r'(\d+([-.]\d+)?)mAh', filepath)
        if match:
            return float(match.group(1).replace('-', '.'))
        return None
```

#### 2.3 PNE 데이터 로더

```python
# data/pne_loader.py

from glob import glob
import pandas as pd

class PNEDataLoader(BaseDataLoader):
    """PNE 사이클러 데이터 로더"""

    def load_all_cycles(self, path: str, config: CapacityConfig) -> CycleDataContainer:
        """PNE Restore 폴더에서 모든 SaveData*.csv 로드"""

        container = CycleDataContainer()

        # 용량 추출
        capacity = self._extract_capacity(path, config)
        container.set_metadata('capacity', capacity)

        # Restore 폴더에서 모든 사이클 파일 찾기
        restore_path = Path(path) / "Restore"
        cycle_files = sorted(restore_path.glob("SaveData*.csv"))

        for file in cycle_files:
            cycle_no = self._extract_cycle_number(file.name)
            df = self._parse_pne_cycle(file)
            container.add_cycle(cycle_no, df)

        return container

    def _extract_cycle_number(self, filename: str) -> int:
        """파일명에서 사이클 번호 추출 (SaveData003.csv → 3)"""
        import re
        match = re.search(r'SaveData(\d+)\.csv', filename)
        if match:
            return int(match.group(1))
        raise ValueError(f"Invalid PNE cycle filename: {filename}")

    def _parse_pne_cycle(self, filepath: Path) -> pd.DataFrame:
        """PNE CSV 파일 파싱"""
        # PNE 특화 파싱 로직
        df = pd.read_csv(filepath)
        # 컬럼 정리, 데이터 변환 등
        return df

    @staticmethod
    def detect_cycler_type(path: str) -> bool:
        """Pattern 폴더 존재 여부로 PNE 판별"""
        pattern_path = Path(path) / "Pattern"
        return pattern_path.exists()
```

#### 2.4 Toyo 데이터 로더

```python
# data/toyo_loader.py

class ToyoDataLoader(BaseDataLoader):
    """Toyo 사이클러 데이터 로더"""

    def load_all_cycles(self, path: str, config: CapacityConfig) -> CycleDataContainer:
        """Toyo raw data에서 전체 로드 및 사이클 분할"""

        container = CycleDataContainer()

        # 용량 추출
        capacity = self._extract_capacity(path, config)
        container.set_metadata('capacity', capacity)

        # Raw data 파일 로드
        raw_data = self._load_toyo_raw(path)

        # Condition 변화 기준으로 사이클 분할
        cycle_boundaries = self._detect_cycle_boundaries(raw_data)

        for cycle_no, (start, end) in cycle_boundaries.items():
            df = raw_data.iloc[start:end].copy()
            container.add_cycle(cycle_no, df)

        return container

    def _load_toyo_raw(self, path: str) -> pd.DataFrame:
        """Toyo raw data 파일 로드"""
        # Toyo 파일 형식 파싱
        raw_file = Path(path) / "raw_data.csv"  # 실제 파일명 확인 필요
        df = pd.read_csv(raw_file)
        return df

    def _detect_cycle_boundaries(self, raw_data: pd.DataFrame) -> Dict[int, Tuple[int, int]]:
        """Condition 변화 기반 사이클 경계 감지"""
        # Condition: 0=휴지, 1=충전, 2=방전
        # 사이클 시작: 휴지(0) → 충전(1) 전환

        boundaries = {}
        cycle_no = 1
        start_idx = 0

        condition_changes = raw_data['Condition'].diff() != 0

        for idx, is_change in enumerate(condition_changes):
            if is_change and raw_data.loc[idx, 'Condition'] == 1:
                # 새 사이클 시작
                if start_idx < idx:
                    boundaries[cycle_no] = (start_idx, idx - 1)
                    cycle_no += 1
                start_idx = idx

        # 마지막 사이클
        if start_idx < len(raw_data):
            boundaries[cycle_no] = (start_idx, len(raw_data) - 1)

        return boundaries

    @staticmethod
    def detect_cycler_type(path: str) -> bool:
        """Pattern 폴더 없으면 Toyo"""
        pattern_path = Path(path) / "Pattern"
        return not pattern_path.exists()
```

#### 2.5 데이터 로더 팩토리

```python
# data/__init__.py

class DataLoaderFactory:
    """사이클러 타입별 로더 자동 생성"""

    @staticmethod
    def create_loader(path: str) -> BaseDataLoader:
        """경로에서 사이클러 타입 감지 후 적절한 로더 반환"""

        if PNEDataLoader.detect_cycler_type(path):
            return PNEDataLoader()
        elif ToyoDataLoader.detect_cycler_type(path):
            return ToyoDataLoader()
        else:
            raise ValueError(f"Unknown cycler type for path: {path}")
```

---

### 3. 분석 전략 시스템 (Analysis)

#### 3.1 전략 기본 클래스

```python
# analysis/strategies/base_strategy.py

from abc import ABC, abstractmethod

class BaseAnalysisStrategy(ABC):
    """분석 전략 추상 기본 클래스"""

    def __init__(self, config: AnalysisConfig):
        self.config = config

    @abstractmethod
    def analyze(self, container: CycleDataContainer) -> AnalysisResult:
        """분석 실행"""
        pass

    @abstractmethod
    def get_subplot_count(self) -> int:
        """서브플롯 개수 (4 or 6)"""
        pass

    @abstractmethod
    def get_data_attr(self) -> str:
        """데이터 속성명 (NewData, stepchg, Profile 등)"""
        pass
```

#### 3.2 Cycle 분석 전략

```python
# analysis/strategies/cycle_strategies.py

class IndividualCycleStrategy(BaseAnalysisStrategy):
    """개별 Cycle 분석 전략"""

    def analyze(self, container: CycleDataContainer) -> AnalysisResult:
        """개별 사이클 분석"""

        cycle_numbers = self.config.cycle_config.cycle_numbers
        results = []

        for cycle_no in cycle_numbers:
            cycle_data = container.get_cycle(cycle_no)

            # 분석 수행
            analysis = self._analyze_single_cycle(cycle_data, container.capacity)
            results.append(analysis)

        return AnalysisResult(
            data=results,
            subplot_count=6,
            layout_type="individual_cycle"
        )

    def _analyze_single_cycle(self, data: pd.DataFrame, capacity: float):
        """단일 사이클 분석"""
        # Cycle life 지표 계산
        return {
            'discharge_capacity': data['Dchg'].values,
            'efficiency': data['Eff'].values,
            'temperature': data['Temp'].values,
            'dcir': data['dcir'].values,
            'avg_voltage': data['AvgV'].values,
            # ...
        }

    def get_subplot_count(self) -> int:
        return 6

    def get_data_attr(self) -> str:
        return "NewData"


class LinkedCycleStrategy(BaseAnalysisStrategy):
    """연결 Cycle 분석 전략"""

    def analyze(self, container: CycleDataContainer) -> AnalysisResult:
        """여러 경로의 사이클을 연결하여 분석"""

        # 사이클 인덱스 누적 조정
        cumulative_cycles = []
        cycle_offset = 0

        for path_idx, path in enumerate(self.config.path.paths):
            path_cycles = container.get_cycles_for_path(path)

            for cycle_no, data in path_cycles.items():
                adjusted_data = data.copy()
                adjusted_data.index += cycle_offset
                cumulative_cycles.append(adjusted_data)

            cycle_offset += len(path_cycles)

        return AnalysisResult(
            data=cumulative_cycles,
            subplot_count=6,
            layout_type="linked_cycle"
        )

    def get_subplot_count(self) -> int:
        return 6

    def get_data_attr(self) -> str:
        return "NewData"


class ReliabilityCycleStrategy(BaseAnalysisStrategy):
    """신뢰성 Cycle 분석 전략 (Toyo 전용)"""

    def analyze(self, container: CycleDataContainer) -> AnalysisResult:
        """Toyo 신뢰성 테스트 분석"""
        # Toyo 특화 분석 로직
        pass

    def get_subplot_count(self) -> int:
        return 6

    def get_data_attr(self) -> str:
        return "NewData"
```

#### 3.3 Profile 분석 전략

```python
# analysis/strategies/profile_strategies.py

class StepProfileStrategy(BaseAnalysisStrategy):
    """충전 Step 프로파일 전략"""

    def analyze(self, container: CycleDataContainer) -> AnalysisResult:
        """Step charge 프로파일 분석"""

        config = self.config.profile_config

        # 연속 vs 개별 처리
        if config.cycle_range:
            start, end = config.cycle_range
            data = container.get_cycle_range(start, end)
            results = self._analyze_continuous(data, container.capacity)
        else:
            results = []
            for cycle_no in config.cycle_numbers:
                cycle_data = container.get_cycle(cycle_no)
                result = self._analyze_discrete(cycle_data, container.capacity)
                results.append(result)

        return AnalysisResult(
            data=results,
            subplot_count=6,
            layout_type="step_profile"
        )

    def get_subplot_count(self) -> int:
        return 6

    def get_data_attr(self) -> str:
        return "stepchg"


class DischargeProfileStrategy(BaseAnalysisStrategy):
    """방전 프로파일 전략 (dQ/dV 포함)"""

    def analyze(self, container: CycleDataContainer) -> AnalysisResult:
        """방전 프로파일 + dQ/dV 분석"""

        config = self.config.profile_config
        results = []

        for cycle_no in config.cycle_numbers:
            cycle_data = container.get_cycle(cycle_no)

            # dQ/dV 계산
            from ..processors.dqdv_processor import DQDVProcessor
            processor = DQDVProcessor(config.smoothing)
            dqdv_data = processor.calculate(cycle_data)

            results.append({
                'profile': cycle_data,
                'dqdv': dqdv_data
            })

        return AnalysisResult(
            data=results,
            subplot_count=6,
            layout_type="discharge_profile"
        )

    def get_subplot_count(self) -> int:
        return 6

    def get_data_attr(self) -> str:
        return "Profile"


class RateProfileStrategy(BaseAnalysisStrategy):
    """율변 충전 프로파일 전략"""

    def analyze(self, container: CycleDataContainer) -> AnalysisResult:
        """Rate capability 프로파일 분석"""
        # Step과 유사하지만 Rate 특화 분석
        pass

    def get_subplot_count(self) -> int:
        return 6

    def get_data_attr(self) -> str:
        return "rateProfile"


class DCIRProfileStrategy(BaseAnalysisStrategy):
    """DCIR 프로파일 전략"""

    def analyze(self, container: CycleDataContainer) -> AnalysisResult:
        """DCIR 분석 (PNE/Toyo)"""

        config = self.config.profile_config

        # 연속 범위 처리
        if config.cycle_range:
            start, end = config.cycle_range
            data = container.get_cycle_range(start, end)
        else:
            data = container.get_cycle(config.cycle_numbers[0])

        # DCIR 계산
        from ..processors.dcir_processor import DCIRProcessor
        processor = DCIRProcessor()
        dcir_data = processor.calculate(data, container.metadata['cycler_type'])

        return AnalysisResult(
            data=dcir_data,
            subplot_count=4,
            layout_type="dcir_profile"
        )

    def get_subplot_count(self) -> int:
        return 4

    def get_data_attr(self) -> str:
        return "dcir"
```

---

### 4. 메인 분석 엔진

```python
# analysis/analyzer.py

class BatteryAnalyzer:
    """메인 분석 엔진 - 전체 워크플로우 조율"""

    def __init__(self, config: AnalysisConfig):
        self.config = config
        self.data_container = None
        self.strategy = None

    def load_data(self, path: str):
        """전체 데이터 로드 (1회만 실행)"""

        # 로더 생성
        loader = DataLoaderFactory.create_loader(path)

        # 전체 사이클 로드
        self.data_container = loader.load_all_cycles(path, self.config.capacity)

        # 사이클러 타입 메타데이터 저장
        cycler_type = "pne" if isinstance(loader, PNEDataLoader) else "toyo"
        self.data_container.set_metadata('cycler_type', cycler_type)

    def set_strategy(self, strategy: BaseAnalysisStrategy):
        """분석 전략 설정"""
        self.strategy = strategy

    def analyze(self) -> AnalysisResult:
        """분석 실행"""

        if not self.data_container:
            raise RuntimeError("데이터를 먼저 로드해야 합니다 (load_data 호출)")

        if not self.strategy:
            raise RuntimeError("분석 전략을 설정해야 합니다 (set_strategy 호출)")

        # 전략 실행
        result = self.strategy.analyze(self.data_container)

        return result

    def visualize(self, result: AnalysisResult):
        """그래프 생성"""

        from visualization.graph_builder import GraphBuilder

        builder = GraphBuilder(result.subplot_count)
        fig = builder.create(result.data, result.layout_type)

        return fig

    def export(self, result: AnalysisResult):
        """데이터 내보내기"""

        if self.config.export.save_excel:
            from export.excel_exporter import ExcelExporter
            exporter = ExcelExporter()
            exporter.export(result.data, self.config.export.excel_filename)

        if self.config.export.save_ect:
            from export.csv_exporter import ECTExporter
            exporter = ECTExporter()
            exporter.export(result.data, self.config.export.ect_filename)
```

---

## 사용 예제

### 예제 1: 개별 Cycle 분석

```python
from battery_analyzer import BatteryAnalyzer, AnalysisConfig
from battery_analyzer.config import PathConfig, CapacityConfig, CycleAnalysisConfig
from battery_analyzer.analysis.strategies import IndividualCycleStrategy

# 설정 생성
config = AnalysisConfig(
    path=PathConfig(
        paths=["Rawdata/A1_MP1_4500mAh_T23_3"]
    ),
    capacity=CapacityConfig(
        mode=CapacityMode.MANUAL,
        manual_capacity=4500
    ),
    cycle_config=CycleAnalysisConfig(
        cycle_numbers=[1, 2, 3, 10, 20]
    )
)

# 분석 실행
analyzer = BatteryAnalyzer(config)
analyzer.load_data(config.path.paths[0])  # 전체 로드 (1회)
analyzer.set_strategy(IndividualCycleStrategy(config))

result = analyzer.analyze()
fig = analyzer.visualize(result)
analyzer.export(result)
```

### 예제 2: 연속 경로 Toyo DCIR

```python
# 연속 경로 설정
config = AnalysisConfig(
    path=PathConfig(
        paths=[
            "Rawdata/250207_250307_3_김동진_1689mAh_ATL Q7M Inner 2C 상온수명 1-100cyc",
            "Rawdata/250219_250319_3_김동진_1689mAh_ATL Q7M Inner 2C 상온수명 101-200cyc"
        ]
    ),
    capacity=CapacityConfig(mode=CapacityMode.AUTO_CRATE, c_rate=0.2),
    profile_config=ProfileAnalysisConfig(
        cycle_range=(3, 5),  # 사이클 3-5 연속 처리
        voltage_min=2.5,
        voltage_max=4.7
    )
)

analyzer = BatteryAnalyzer(config)

# 각 경로 로드
for path in config.path.paths:
    analyzer.load_data(path)

# DCIR 전략 (Toyo 지원)
from battery_analyzer.analysis.strategies import DCIRProfileStrategy
analyzer.set_strategy(DCIRProfileStrategy(config))

result = analyzer.analyze()
fig = analyzer.visualize(result)
```

---

## 다음 단계

Phase 2의 나머지 문서:
1. **Data Loader 상세 설계** - CycleDataContainer, PNE/Toyo 로더 구현 상세
2. **확장 기능 설계** - Toyo DCIR, Profile 연속성 구현 방안

이 문서는 전체 아키텍처의 청사진을 제공합니다.
